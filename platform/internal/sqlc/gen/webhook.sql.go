// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: webhook.sql

package sqlc

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const closeCircuitForURL = `-- name: CloseCircuitForURL :exec
UPDATE webhook_deliveries
SET circuit_open_until = NULL, consecutive_failures = 0, updated_at = NOW()
WHERE webhook_url = $1
`

func (q *Queries) CloseCircuitForURL(ctx context.Context, webhookUrl string) error {
	_, err := q.db.Exec(ctx, closeCircuitForURL, webhookUrl)
	return err
}

const createWebhookDelivery = `-- name: CreateWebhookDelivery :one
INSERT INTO webhook_deliveries (
    request_id, agent_id, webhook_url, webhook_secret_hash
) VALUES ($1, $2, $3, $4)
RETURNING id, request_id, agent_id, webhook_url, webhook_secret_hash, seq, last_event_type, status, attempt_count, last_attempt_at, next_retry_at, last_error, consecutive_failures, circuit_open_until, created_at, updated_at, completed_at
`

type CreateWebhookDeliveryParams struct {
	RequestID         string         `json:"request_id"`
	AgentID           string         `json:"agent_id"`
	WebhookUrl        string         `json:"webhook_url"`
	WebhookSecretHash sql.NullString `json:"webhook_secret_hash"`
}

func (q *Queries) CreateWebhookDelivery(ctx context.Context, arg *CreateWebhookDeliveryParams) (*WebhookDelivery, error) {
	row := q.db.QueryRow(ctx, createWebhookDelivery,
		arg.RequestID,
		arg.AgentID,
		arg.WebhookUrl,
		arg.WebhookSecretHash,
	)
	var i WebhookDelivery
	err := row.Scan(
		&i.ID,
		&i.RequestID,
		&i.AgentID,
		&i.WebhookUrl,
		&i.WebhookSecretHash,
		&i.Seq,
		&i.LastEventType,
		&i.Status,
		&i.AttemptCount,
		&i.LastAttemptAt,
		&i.NextRetryAt,
		&i.LastError,
		&i.ConsecutiveFailures,
		&i.CircuitOpenUntil,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
	)
	return &i, err
}

const getActiveDeliveriesForAgent = `-- name: GetActiveDeliveriesForAgent :many
SELECT id, request_id, agent_id, webhook_url, webhook_secret_hash, seq, last_event_type, status, attempt_count, last_attempt_at, next_retry_at, last_error, consecutive_failures, circuit_open_until, created_at, updated_at, completed_at FROM webhook_deliveries
WHERE agent_id = $1
  AND status IN ('pending', 'delivering')
ORDER BY created_at DESC
`

func (q *Queries) GetActiveDeliveriesForAgent(ctx context.Context, agentID string) ([]*WebhookDelivery, error) {
	rows, err := q.db.Query(ctx, getActiveDeliveriesForAgent, agentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*WebhookDelivery{}
	for rows.Next() {
		var i WebhookDelivery
		if err := rows.Scan(
			&i.ID,
			&i.RequestID,
			&i.AgentID,
			&i.WebhookUrl,
			&i.WebhookSecretHash,
			&i.Seq,
			&i.LastEventType,
			&i.Status,
			&i.AttemptCount,
			&i.LastAttemptAt,
			&i.NextRetryAt,
			&i.LastError,
			&i.ConsecutiveFailures,
			&i.CircuitOpenUntil,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getConsecutiveFailures = `-- name: GetConsecutiveFailures :one
SELECT COALESCE(MAX(consecutive_failures), 0)::int AS failures
FROM webhook_deliveries
WHERE webhook_url = $1
  AND status IN ('pending', 'delivering')
`

func (q *Queries) GetConsecutiveFailures(ctx context.Context, webhookUrl string) (int32, error) {
	row := q.db.QueryRow(ctx, getConsecutiveFailures, webhookUrl)
	var failures int32
	err := row.Scan(&failures)
	return failures, err
}

const getPendingRetries = `-- name: GetPendingRetries :many
SELECT id, request_id, agent_id, webhook_url, webhook_secret_hash, seq, last_event_type, status, attempt_count, last_attempt_at, next_retry_at, last_error, consecutive_failures, circuit_open_until, created_at, updated_at, completed_at FROM webhook_deliveries
WHERE status = 'pending'
  AND next_retry_at IS NOT NULL
  AND next_retry_at <= NOW()
  AND (circuit_open_until IS NULL OR circuit_open_until <= NOW())
ORDER BY next_retry_at
LIMIT $1
`

func (q *Queries) GetPendingRetries(ctx context.Context, limit int32) ([]*WebhookDelivery, error) {
	rows, err := q.db.Query(ctx, getPendingRetries, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*WebhookDelivery{}
	for rows.Next() {
		var i WebhookDelivery
		if err := rows.Scan(
			&i.ID,
			&i.RequestID,
			&i.AgentID,
			&i.WebhookUrl,
			&i.WebhookSecretHash,
			&i.Seq,
			&i.LastEventType,
			&i.Status,
			&i.AttemptCount,
			&i.LastAttemptAt,
			&i.NextRetryAt,
			&i.LastError,
			&i.ConsecutiveFailures,
			&i.CircuitOpenUntil,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWebhookDelivery = `-- name: GetWebhookDelivery :one
SELECT id, request_id, agent_id, webhook_url, webhook_secret_hash, seq, last_event_type, status, attempt_count, last_attempt_at, next_retry_at, last_error, consecutive_failures, circuit_open_until, created_at, updated_at, completed_at FROM webhook_deliveries WHERE request_id = $1
`

func (q *Queries) GetWebhookDelivery(ctx context.Context, requestID string) (*WebhookDelivery, error) {
	row := q.db.QueryRow(ctx, getWebhookDelivery, requestID)
	var i WebhookDelivery
	err := row.Scan(
		&i.ID,
		&i.RequestID,
		&i.AgentID,
		&i.WebhookUrl,
		&i.WebhookSecretHash,
		&i.Seq,
		&i.LastEventType,
		&i.Status,
		&i.AttemptCount,
		&i.LastAttemptAt,
		&i.NextRetryAt,
		&i.LastError,
		&i.ConsecutiveFailures,
		&i.CircuitOpenUntil,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
	)
	return &i, err
}

const getWebhookDeliveryByID = `-- name: GetWebhookDeliveryByID :one
SELECT id, request_id, agent_id, webhook_url, webhook_secret_hash, seq, last_event_type, status, attempt_count, last_attempt_at, next_retry_at, last_error, consecutive_failures, circuit_open_until, created_at, updated_at, completed_at FROM webhook_deliveries WHERE id = $1
`

func (q *Queries) GetWebhookDeliveryByID(ctx context.Context, id uuid.UUID) (*WebhookDelivery, error) {
	row := q.db.QueryRow(ctx, getWebhookDeliveryByID, id)
	var i WebhookDelivery
	err := row.Scan(
		&i.ID,
		&i.RequestID,
		&i.AgentID,
		&i.WebhookUrl,
		&i.WebhookSecretHash,
		&i.Seq,
		&i.LastEventType,
		&i.Status,
		&i.AttemptCount,
		&i.LastAttemptAt,
		&i.NextRetryAt,
		&i.LastError,
		&i.ConsecutiveFailures,
		&i.CircuitOpenUntil,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
	)
	return &i, err
}

const isCircuitOpen = `-- name: IsCircuitOpen :one
SELECT EXISTS (
    SELECT 1 FROM webhook_deliveries
    WHERE webhook_url = $1
      AND circuit_open_until IS NOT NULL
      AND circuit_open_until > NOW()
) AS is_open
`

func (q *Queries) IsCircuitOpen(ctx context.Context, webhookUrl string) (bool, error) {
	row := q.db.QueryRow(ctx, isCircuitOpen, webhookUrl)
	var is_open bool
	err := row.Scan(&is_open)
	return is_open, err
}

const markDeliveryCompleted = `-- name: MarkDeliveryCompleted :exec
UPDATE webhook_deliveries
SET status = 'completed', completed_at = NOW(), updated_at = NOW(), consecutive_failures = 0
WHERE request_id = $1
`

func (q *Queries) MarkDeliveryCompleted(ctx context.Context, requestID string) error {
	_, err := q.db.Exec(ctx, markDeliveryCompleted, requestID)
	return err
}

const markDeliveryFailed = `-- name: MarkDeliveryFailed :exec
UPDATE webhook_deliveries
SET status = 'failed', updated_at = NOW()
WHERE request_id = $1
`

func (q *Queries) MarkDeliveryFailed(ctx context.Context, requestID string) error {
	_, err := q.db.Exec(ctx, markDeliveryFailed, requestID)
	return err
}

const openCircuitForURL = `-- name: OpenCircuitForURL :exec
UPDATE webhook_deliveries
SET circuit_open_until = $2, updated_at = NOW()
WHERE webhook_url = $1 AND (circuit_open_until IS NULL OR circuit_open_until < NOW())
`

type OpenCircuitForURLParams struct {
	WebhookUrl       string       `json:"webhook_url"`
	CircuitOpenUntil sql.NullTime `json:"circuit_open_until"`
}

func (q *Queries) OpenCircuitForURL(ctx context.Context, arg *OpenCircuitForURLParams) error {
	_, err := q.db.Exec(ctx, openCircuitForURL, arg.WebhookUrl, arg.CircuitOpenUntil)
	return err
}

const recordDeliveryAttempt = `-- name: RecordDeliveryAttempt :exec
UPDATE webhook_deliveries
SET attempt_count = attempt_count + 1,
    last_attempt_at = NOW(),
    updated_at = NOW()
WHERE request_id = $1
`

func (q *Queries) RecordDeliveryAttempt(ctx context.Context, requestID string) error {
	_, err := q.db.Exec(ctx, recordDeliveryAttempt, requestID)
	return err
}

const recordDeliveryFailure = `-- name: RecordDeliveryFailure :exec
UPDATE webhook_deliveries
SET last_error = $2,
    consecutive_failures = consecutive_failures + 1,
    next_retry_at = $3,
    updated_at = NOW()
WHERE request_id = $1
`

type RecordDeliveryFailureParams struct {
	RequestID   string         `json:"request_id"`
	LastError   sql.NullString `json:"last_error"`
	NextRetryAt sql.NullTime   `json:"next_retry_at"`
}

func (q *Queries) RecordDeliveryFailure(ctx context.Context, arg *RecordDeliveryFailureParams) error {
	_, err := q.db.Exec(ctx, recordDeliveryFailure, arg.RequestID, arg.LastError, arg.NextRetryAt)
	return err
}

const recordDeliverySuccess = `-- name: RecordDeliverySuccess :exec
UPDATE webhook_deliveries
SET consecutive_failures = 0,
    last_error = NULL,
    next_retry_at = NULL,
    updated_at = NOW()
WHERE request_id = $1
`

func (q *Queries) RecordDeliverySuccess(ctx context.Context, requestID string) error {
	_, err := q.db.Exec(ctx, recordDeliverySuccess, requestID)
	return err
}

const updateDeliverySeq = `-- name: UpdateDeliverySeq :exec
UPDATE webhook_deliveries
SET seq = $2, last_event_type = $3, updated_at = NOW()
WHERE request_id = $1
`

type UpdateDeliverySeqParams struct {
	RequestID     string         `json:"request_id"`
	Seq           int64          `json:"seq"`
	LastEventType sql.NullString `json:"last_event_type"`
}

func (q *Queries) UpdateDeliverySeq(ctx context.Context, arg *UpdateDeliverySeqParams) error {
	_, err := q.db.Exec(ctx, updateDeliverySeq, arg.RequestID, arg.Seq, arg.LastEventType)
	return err
}

const updateDeliveryStatus = `-- name: UpdateDeliveryStatus :exec
UPDATE webhook_deliveries
SET status = $2, updated_at = NOW()
WHERE request_id = $1
`

type UpdateDeliveryStatusParams struct {
	RequestID string `json:"request_id"`
	Status    string `json:"status"`
}

func (q *Queries) UpdateDeliveryStatus(ctx context.Context, arg *UpdateDeliveryStatusParams) error {
	_, err := q.db.Exec(ctx, updateDeliveryStatus, arg.RequestID, arg.Status)
	return err
}
